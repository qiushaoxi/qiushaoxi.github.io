<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Tiny Hill's Blog" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="keywords" content="区块链">
<meta property="og:type" content="website">
<meta property="og:title" content="Tiny Hill&#39;s Blog">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="Tiny Hill&#39;s Blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>Tiny Hill's Blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-120660538-5"></script>
    <script>
      var host = window.location.hostname;
      if (host !== "localhost" || !true) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-120660538-5');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tiny Hill's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">区块链小山的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/07/2017-12-07-fabric-in-swarm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tiny Hill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tiny Hill's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/07/2017-12-07-fabric-in-swarm/" class="post-title-link" itemprop="url">在 Swarm 集群环境部署 Fabric 区块链</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-07 12:55:00" itemprop="dateCreated datePublished" datetime="2017-12-07T12:55:00+08:00">2017-12-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-09 08:05:10" itemprop="dateModified" datetime="2019-11-09T08:05:10+08:00">2019-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">区块链技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>fabric 部署本来就是一件麻烦的事情，如果还涉及到多机环境部署那就更加的麻烦了。<br>因为 fabric 推荐部署在docker环境中，那很自然地想到通过集群部署工具来部署fabric。本文就通过例子来说明如何在 Swarm 集群中部署 fabric 区块链网络。</p>
<p>还有之前看到过张海宁的<a href="https://github.com/hainingzhang/articles/blob/master/fabric_multi_nodes/FabricMultiNodev2-3.pdf" target="_blank" rel="noopener">k8s部署方案</a>，供大家参考。</p>
<p>文中所有IP地址,如192.168.1.93，都需要根据你本地的情况输入。</p>
<p>本例子github地址：<a href="https://github.com/qiushaoxi/fabric-in-swarm.git" target="_blank" rel="noopener">fabric-in-swarm</a> , 欢迎star.</p>
<h2 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h2><p><img src="/img/fabric-in-swarm/architect.png" alt="架构图"></p>
<p>docker swarm 会在各台机器之上 创建一个 overlay 虚拟网络，通过swarm启动的container可以跨主机互相访问。</p>
<p>docker service 是 swarm 编排的最小单位，可以配置运行的镜像、网络端口、环境变量等，一个service 可以启动多个container进行负载均衡。不过因为区块链中每个节点都有不同的配置，本例子中每个service只跑一个container。后续可以继续探讨启动多个container的场景。</p>
<p>docker stack 则是一组 service 的合集， 每个stack会默认创建一个 default 的 overlay 网络，其中还可以再配置其他网络。 stack 本意是技术栈，通过在 stack 中配置前后端、中间件等 service，可以实现一键部署整个技术栈。本例子的stack 中，配置了1个orderer、4个peer和1个cli一共6个service。后续可以根据需要加入kafka、couchdb等service。</p>
<p>swarm 集群会对外暴露一个IP，通过端口映射，可以访问到具体 service 的端口。</p>
<h2 id="基础环境搭建"><a href="#基础环境搭建" class="headerlink" title="基础环境搭建"></a>基础环境搭建</h2><h3 id="Swarm-集群搭建"><a href="#Swarm-集群搭建" class="headerlink" title="Swarm 集群搭建"></a>Swarm 集群搭建</h3><h4 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h4><p>如果还没有安装 docker ，执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com | sh</span><br></pre></td></tr></table></figure>
<h4 id="在-leader-创建-Swarm-集群"><a href="#在-leader-创建-Swarm-集群" class="headerlink" title="在 leader 创建 Swarm 集群"></a>在 leader 创建 Swarm 集群</h4><p>选择一台机器作为 leader</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init --advertise-addr 192.168.1.93</span><br></pre></td></tr></table></figure>
<p>这里的ip是整个swarm集群对外的ip，所有swarm集群里面的容器都通过这个ip对外提供服务。</p>
<p>执行返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"> </span><br><span class="line">    docker swarm join /</span><br><span class="line">    --token SWMTKN-1-16kit6dksvrqilgptjg5pvu0tvo5qfs8uczjq458lf9mul41hc-dzvgu0h3qngfgihz4fv0855bo /</span><br><span class="line">    192.168.1.93:2377</span><br><span class="line"> </span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure>
<h4 id="其他机器加入-Swarm-集群"><a href="#其他机器加入-Swarm-集群" class="headerlink" title="其他机器加入 Swarm 集群"></a>其他机器加入 Swarm 集群</h4><p>根据第一步返回的命令加入集群：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join /</span><br><span class="line">--token SWMTKN-1-16kit6dksvrqilgptjg5pvu0tvo5qfs8uczjq458lf9mul41hc-dzvgu0h3qngfgihz4fv0855bo /</span><br><span class="line">192.168.1.93:2377</span><br></pre></td></tr></table></figure>
<p>所有其他机器执行命令后，在leader执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker node ls</span><br></pre></td></tr></table></figure>
<p>如果能看到所有机器，说明操作成功，Swarm集群搭建完毕。</p>
<h4 id="portainer"><a href="#portainer" class="headerlink" title="portainer"></a>portainer</h4><p>这里推荐一个开源的docker后台管理工具<a href="https://portainer.io/" target="_blank" rel="noopener">portainer</a>，也支持Swarm集群的管理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish 9000:9000 \</span><br><span class="line">--replicas=1 \</span><br><span class="line">--constraint &apos;node.role == manager&apos; \</span><br><span class="line">--mount type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">portainer/portainer \</span><br><span class="line">-H unix:///var/run/docker.sock</span><br></pre></td></tr></table></figure>
<p>执行这个命令就可以在Swarm中启动，然后访问 Swarm_IP:9000 就可以进行管理后台，初次需要设置密码。</p>
<h3 id="NFS服务器搭建"><a href="#NFS服务器搭建" class="headerlink" title="NFS服务器搭建"></a>NFS服务器搭建</h3><p>因为集群容器需要读取一些文件，所以需要搭一个文件服务器。</p>
<h4 id="安装nfs-kernel-server"><a href="#安装nfs-kernel-server" class="headerlink" title="安装nfs-kernel-server"></a>安装nfs-kernel-server</h4><p>可以在任意台机器安装，本例子就在 swarm manager的机器上安装的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install nfs-common</span><br><span class="line">apt install nfs-kernel-server</span><br></pre></td></tr></table></figure>
<h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/exports</span><br></pre></td></tr></table></figure>
<p>修改内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/nfs *(rw,sync,no_root_squash)</span><br></pre></td></tr></table></figure>
<p>各段表达的意思如下，根据实际进行修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/nfs   ：共享的目录</span><br><span class="line">*       ：指定哪些用户可以访问</span><br><span class="line">            *  所有可以ping同该主机的用户</span><br><span class="line">            192.168.1.*  指定网段，在该网段中的用户可以挂载</span><br><span class="line">            192.168.1.12 只有该用户能挂载</span><br><span class="line">(ro,sync,no_root_squash)：  权限</span><br><span class="line">        ro : 只读</span><br><span class="line">        rw : 读写</span><br><span class="line">        sync :  同步</span><br><span class="line">        no_root_squash: 不降低root用户的权限</span><br><span class="line">    其他选项man 5 exports 查看</span><br></pre></td></tr></table></figure>
<h4 id="创建目录并重启nfs服务"><a href="#创建目录并重启nfs服务" class="headerlink" title="创建目录并重启nfs服务"></a>创建目录并重启nfs服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /nfs</span><br><span class="line">service nfs-kernel-server restart</span><br></pre></td></tr></table></figure>
<p>到此，nfs的服务就搭建好了。</p>
<h4 id="连接挂载nfs服务器"><a href="#连接挂载nfs服务器" class="headerlink" title="连接挂载nfs服务器"></a>连接挂载nfs服务器</h4><p>执行 showmount -e + 主机IP 测试和nfs服务器是否能够联通</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt install nfs-common</span><br><span class="line"></span><br><span class="line">showmount -e 192.168.1.93</span><br></pre></td></tr></table></figure>
<p>如果看到返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Export list for 192.168.1.93:</span><br><span class="line">/nfs *</span><br></pre></td></tr></table></figure>
<p>说明文件服务器是ok的。</p>
<p>将该目录挂载到本地，每个机器都需要挂载，包括管理节点的机器。为的是保证每台机器都能够从/mnt/nfs/目录获取数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mnt/nfs</span><br><span class="line">mount 192.168.1.93:/nfs  /mnt/nfs</span><br></pre></td></tr></table></figure>
<p>访问本地的/mnt/nfs目录，就可访问服务端共享的目录了。</p>
<h2 id="部署-Fabric"><a href="#部署-Fabric" class="headerlink" title="部署 Fabric"></a>部署 Fabric</h2><h3 id="部署文件准备"><a href="#部署文件准备" class="headerlink" title="部署文件准备"></a>部署文件准备</h3><p>进入nfs目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /mnt/nfs</span><br></pre></td></tr></table></figure>
<p>从github获取示例脚本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/qiushaoxi/fabric-in-swarm.git</span><br><span class="line">cd fabric-in-swarm</span><br></pre></td></tr></table></figure>
<p>每个节点都需要有fabric相关的docker image，我例子使用fabric 1.0.0版本。</p>
<p>如果还没有，需要在每台机器执行下载脚本，拉取image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash download-dockerimages.sh</span><br></pre></td></tr></table></figure>
<p>如果觉得下载速度太慢，可以使用阿里云镜像加速，或者在本地部署docker hub，具体方法可以参考<a href="http://qiushaoxi.com/2017/12/05/Docker-Hub-Configration/" target="_blank" rel="noopener">本地Docker Hub配置</a>.</p>
<h3 id="执行部署命令"><a href="#执行部署命令" class="headerlink" title="执行部署命令"></a>执行部署命令</h3><p>设置相关环境变量，FABRIC_IP是你Swarm管理节点的ip</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export FABRIC_IP=192.168.1.93</span><br></pre></td></tr></table></figure>
<p>执行docker stack deploy命令启动stack，docker-compose-cli.yaml是docker-compose v3 配置文件，配置了相关的service。</p>
<p>示例的配置参考fabric官方e2e_cli，1个orderer，4个peer，一个cli。命令最后的 e2e 是stack的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd e2e_cli</span><br><span class="line">docker stack deploy -c docker-compose-cli.yaml e2e</span><br></pre></td></tr></table></figure>
<p>docker-compose文件中配置了cli容器会自动执行脚本，执行创建通道、加入通道等一系列操作。</p>
<p>docker service 会根据每台机器的性能和负载，选择启动container的机器。</p>
<p><img src="/img/fabric-in-swarm/cluster.png" alt="运行情况"></p>
<h3 id="查看执行结果"><a href="#查看执行结果" class="headerlink" title="查看执行结果"></a>查看执行结果</h3><p>执行下面命令，查询执行日志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service logs -f e2e_cli</span><br></pre></td></tr></table></figure>

<p>如果看不到内容，（我在本地可以用这个命令，阿里云看不到，原因不明）。执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ps e2e_cli</span><br></pre></td></tr></table></figure>
<p>可以看到cli容器的id和运行在哪台机器上。</p>
<p>到运行cli容器的机器上执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs [cli_container_id]</span><br></pre></td></tr></table></figure>
<p>查看执行日志。</p>
<p>如果最后出现 END-E2E，则说明执行成功。</p>
<h3 id="移除-stack"><a href="#移除-stack" class="headerlink" title="移除 stack"></a>移除 stack</h3><p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm e2e</span><br></pre></td></tr></table></figure>
<p>就可以停止并移除所有配置启动的service。</p>
<h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p>查看stack</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack ls</span><br></pre></td></tr></table></figure>
<p>查看service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ls</span><br></pre></td></tr></table></figure>
<p>因为运行chaincode的container是通过unix://var/run/docker.sock启动的，不是由swarm启动的，所以通过docker service 是看不到的。需要到具体执行的机器上执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p>才能看到。</p>
<p>而且，就算是停止了stack也不会自动删除这些container，不过因为peer停止了，这些chaincode的container也会自动停止。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://www.jianshu.com/p/748416621013" target="_blank" rel="noopener">Docker Compose 配置文件详解（V3）</a></p>
<p><a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">官方接口文档</a></p>
<p><a href="http://blog.csdn.net/u014743697/article/details/53004638" target="_blank" rel="noopener">多主机网络下 Docker Swarm 模式的容器管理</a></p>
<p><a href="https://www.cnblogs.com/MoreExcellent/p/7222895.html" target="_blank" rel="noopener">ubuntu 16.04 nfs服务的搭建</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/05/2017-12-05-Docker-Hub-Configration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tiny Hill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tiny Hill's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/05/2017-12-05-Docker-Hub-Configration/" class="post-title-link" itemprop="url">本地Docker Hub配置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-12-05 12:55:00" itemprop="dateCreated datePublished" datetime="2017-12-05T12:55:00+08:00">2017-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-09 08:05:20" itemprop="dateModified" datetime="2019-11-09T08:05:20+08:00">2019-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>网上配置贴非常多，但是因为系统版本和docker版本不同略有差异，本贴环境 ubuntu 16.04 docker-ce 17.0x</p>
</blockquote>
<h1 id="启动-regisrty-容器"><a href="#启动-regisrty-容器" class="headerlink" title="启动 regisrty 容器"></a>启动 regisrty 容器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 -v /mnt/date/registry:/var/lib/registry registry</span><br></pre></td></tr></table></figure>

<p>-d后台运行</p>
<p>-p指定端口</p>
<p>-v把registry的镜像路径/var/lib/registry映射到本机的/mnt/date/registry</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 0.0.0.0:5000/v2/_catalog</span><br></pre></td></tr></table></figure>
<p>返回目前regisrty存在的image，不报错说明服务启动成功。</p>
<h1 id="修改docker-https配置"><a href="#修改docker-https配置" class="headerlink" title="修改docker https配置"></a>修改docker https配置</h1><p>因为docker镜像的push和pull默认进过https传输，本地的registry并没有启动https的连接，所以要修改部分配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<p>打开docker配置文件，需要root权限</p>
<p>在ExecStart参数最后加上 –insecure-registry [registry_ip]:[registry_port],如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H fd:// -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock  --insecure-registry 192.168.23.113:5000</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>重新加载docker.service文件的配置，并重启docker服务。</p>
<h1 id="推送镜像到本地的hub"><a href="#推送镜像到本地的hub" class="headerlink" title="推送镜像到本地的hub"></a>推送镜像到本地的hub</h1><p>首先要tag现有的image</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag hyperledger/fabric-kafka 192.168.23.113:5000/fabric-kafka</span><br></pre></td></tr></table></figure>
<p>然后推送image到本地镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.23.113:5000/fabric-kafka</span><br></pre></td></tr></table></figure>

<h1 id="从本地hub拉取镜像"><a href="#从本地hub拉取镜像" class="headerlink" title="从本地hub拉取镜像"></a>从本地hub拉取镜像</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.23.113:5000/fabric-kafka</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/29/2017-11-29-RYB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tiny Hill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tiny Hill's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/29/2017-11-29-RYB/" class="post-title-link" itemprop="url">三原色事件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-29 12:55:00" itemprop="dateCreated datePublished" datetime="2017-11-29T12:55:00+08:00">2017-11-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-09 08:05:26" itemprop="dateModified" datetime="2019-11-09T08:05:26+08:00">2019-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A4%BE%E4%BC%9A/" itemprop="url" rel="index">
                    <span itemprop="name">社会</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>一生都是和这个世界的抗争，没有一刻可以安枕无忧</p>
</blockquote>
<p>从携程亲子园、到三原色幼儿园，这个冬天有点遭心，大概是给党的献礼吧。</p>
<p>想想这些也没什么新鲜的，舆论又重新进入事件的惯有逻辑，每个人选择相信自己相信的事情。只是从前那些事情谁又能想起呢？别说远的，江歌事件才过去没几天就没人再提起了。</p>
<p>我是个很懒的人，懒到写东西也不太愿意，<br>我是个健忘的人，和大众一样，只有几天的记忆，<br>可是我不想忘记这些，这些不该被忘记的事情。</p>
<p>这些事情不断的告诉我，这始终都是个丛林的世界，不要寄希望于任何人，只能靠自己。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/09/2017-11-09-Release-Note-Fabric-v1.1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tiny Hill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tiny Hill's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/09/2017-11-09-Release-Note-Fabric-v1.1/" class="post-title-link" itemprop="url">Fabric v1.1 版本新功能简析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-09 17:55:00" itemprop="dateCreated datePublished" datetime="2017-11-09T17:55:00+08:00">2017-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-09 08:05:33" itemprop="dateModified" datetime="2019-11-09T08:05:33+08:00">2019-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">区块链技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文内容参考官方版本说明：<br><a href="https://github.com/hyperledger/fabric/releases/tag/v1.1.0-preview" target="_blank" rel="noopener">v1.1.0-preview</a> ，简单看了一下变动，后续如果有时间会写更详细的内容。</p>
</blockquote>
<p>官方已经发布v1.1.0-preview版本，V1.1正式版也不远了，来看看这个版本都增加了哪些功能。</p>
<h2 id="FAB-2331-Node-js-Chaincode-支持"><a href="#FAB-2331-Node-js-Chaincode-支持" class="headerlink" title="FAB-2331 - Node.js Chaincode 支持"></a><a href="https://jira.hyperledger.org/browse/FAB-2331" target="_blank" rel="noopener">FAB-2331</a> - Node.js Chaincode 支持</h2><p>增加了Node.js开发Chaincode的支持，原先支持Golang和java开发Chaincode，具体内容可以关注<a href="https://github.com/hyperledger/fabric-chaincode-node" target="_blank" rel="noopener">fabric-chaincode-node</a>项目，开发模型和go差不多，通过shim接口调用。</p>
<h2 id="FAB-5363-Node-js-SDK-Connection-Profile"><a href="#FAB-5363-Node-js-SDK-Connection-Profile" class="headerlink" title="FAB-5363 - Node.js SDK Connection Profile"></a><a href="https://jira.hyperledger.org/browse/FAB-5363" target="_blank" rel="noopener">FAB-5363</a> - Node.js SDK Connection Profile</h2><p>通过配置文件的方式管理SDK的连接。参考原先官方的供的node sdk的sample，也有通过配置文件的方式配置连接地址，但是在sdk的外层。目前看，这个功能应该是sdk自带的属性。</p>
<p>配置文件中包含peer节点、orderer节点的地址，和一些加密信息的配置，基本上使用中所需要的配置内容都集中到这个文件中，通过sdk接口可以方便读取。</p>
<p>以下是简单的例子：</p>
<p>var client = Client.loadFromConfig(json)</p>
<p>var mychannel = client.getChannel(‘mychannel’)</p>
<p>mychannel.sendTransactionProposal()</p>
<p>mychannel.sendTransaction()</p>
<h2 id="FAB-830-Encryption-library-for-chaincode"><a href="#FAB-830-Encryption-library-for-chaincode" class="headerlink" title="FAB-830 - Encryption library for chaincode"></a><a href="https://jira.hyperledger.org/browse/FAB-830" target="_blank" rel="noopener">FAB-830</a> - Encryption library for chaincode</h2><p>给Chaincode增加了加密套件，这个东西还是比较重要的，方便用户对上链数据进行灵活的加密。</p>
<h2 id="FAB-5346-Attribute-based-Access-Control"><a href="#FAB-5346-Attribute-based-Access-Control" class="headerlink" title="FAB-5346 - Attribute-based Access Control"></a><a href="https://jira.hyperledger.org/browse/FAB-5346" target="_blank" rel="noopener">FAB-5346</a> - Attribute-based Access Control</h2><p>基于属性的权限控制。简单说就是在Ecert中加入特定的属性，让chaincode可以根据这个属性进行更加丰富的权限控制。</p>
<h2 id="FAB-6089-Chaincode-APIs-to-retrieve-creator-cert-info"><a href="#FAB-6089-Chaincode-APIs-to-retrieve-creator-cert-info" class="headerlink" title="FAB-6089 - Chaincode APIs to retrieve creator cert info"></a><a href="https://jira.hyperledger.org/browse/FAB-6089" target="_blank" rel="noopener">FAB-6089</a> - Chaincode APIs to retrieve creator cert info</h2><p>新增了GetCreator接口方法用来获取交易发起者的信息，方便进行权限控制。</p>
<h2 id="FAB-6421-Performance-improvements"><a href="#FAB-6421-Performance-improvements" class="headerlink" title="FAB-6421 - Performance improvements"></a><a href="https://jira.hyperledger.org/browse/FAB-6421" target="_blank" rel="noopener">FAB-6421</a> - Performance improvements</h2><p>性能优化</p>
<h2 id="bug修复和其他修改请看Change-Log"><a href="#bug修复和其他修改请看Change-Log" class="headerlink" title="bug修复和其他修改请看Change Log"></a>bug修复和其他修改请看<a href="https://github.com/hyperledger/fabric/blob/master/CHANGELOG.md#v110-preview" target="_blank" rel="noopener">Change Log</a></h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/08/2017-11-08-Fabric-FAQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tiny Hill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tiny Hill's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/08/2017-11-08-Fabric-FAQ/" class="post-title-link" itemprop="url">[翻译]Hyperledger Fabric 答疑</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-11-08 17:55:00" itemprop="dateCreated datePublished" datetime="2017-11-08T17:55:00+08:00">2017-11-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-09 08:05:36" itemprop="dateModified" datetime="2019-11-09T08:05:36+08:00">2019-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">区块链技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>本文同时贡献在<a href="https://hyperledgercn.github.io/hyperledgerDocs/" target="_blank" rel="noopener">超级账本文档中文翻译项目</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>原文</th>
<th>作者</th>
<th>审核修正</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://hyperledger-fabric.readthedocs.io/en/latest/Fabric-FAQ.html" target="_blank" rel="noopener">原文</a></td>
<td>Shaoxi Qiu</td>
<td></td>
</tr>
</tbody></table>
<h2 id="Endorsement背书"><a href="#Endorsement背书" class="headerlink" title="Endorsement背书"></a>Endorsement<br />背书</h2><p><strong>Endorsement architecture</strong>:</p>
<p><strong>背书操作架构</strong>:</p>
<p>Q. How many peers in the network need to endorse a transaction?</p>
<p>问题：多少个网络中的节点需要对交易进行背书？</p>
<p>A. The number of peers required to endorse a transaction is driven by the endorsement<br>policy that is specified at chaincode deployment time.</p>
<p>答案：需要对交易进行背书操作的节点数量由背书策略决定，背书策略在链码部署的时候指定。</p>
<p>Q. Does an application client need to connect to all peers?</p>
<p>问题：应用客户端需要连接到所有节点吗？</p>
<p>A. Clients only need to connect to as many peers as are required by the<br>endorsement policy for the chaincode.</p>
<p>答案：客户端只需要连接到链码对应的背书策略所要求的足够多的节点。</p>
<h2 id="Security-amp-Access-Control安全和权限控制"><a href="#Security-amp-Access-Control安全和权限控制" class="headerlink" title="Security &amp; Access Control安全和权限控制"></a>Security &amp; Access Control<br />安全和权限控制</h2><p><strong>Data Privacy and Access Control</strong>:</p>
<p><strong>数据隐私和权限控制</strong>:</p>
<p>Q. How do I ensure data privacy?</p>
<p>问题：我如何能够保证数据的隐私？</p>
<p>A. There are various aspects to data privacy.<br>First, you can segregate your network into channels, where each channel<br>represents a subset of participants that are authorized to see the data<br>for the chaincodes that are deployed to that channel.<br>Second, within a channel you can restrict the input data to chaincode to the<br>set of endorsers only, by using visibility settings. The visibility setting<br>will determine whether input and output chaincode data is included in the<br>submitted transaction,  versus just output data.<br>Third, you can hash or encrypt the data before calling chaincode. If you hash<br>the data then you will need to provide a means to share the source data.<br>If you encrypt the data then you will need to provide a means to share the<br>decryption keys.<br>Fourth, you can restrict data access to certain roles in your organization, by<br>building access control into the chaincode logic.<br>Fifth, ledger data at rest can be encrypted via file system encryption on<br>the peer, and data in-transit is encrypted via TLS.</p>
<p>答案：数据隐私包括几个方面。</p>
<p>第一、你可以将你的网络拆分为多个通道，每个通道代表参与者的子集，这些参与者有权访问该通道所部署的链码所包含的数据。</p>
<p>第二、通过通道你可以限制链码的输入数据只对背书节点可见。可见性设置将决定链码的输入输出数据是否包含在提交交易中，可以只包含输出数据。</p>
<p>第三、你能在调用链码前对数据进行哈希操作或者加密。如果对数据进行哈希操作，你需要提供获取原数据的方式。如果对数据进行加密，你需要提供获取密钥的方式。</p>
<p>第四、你可以通过链码中的访问控制逻辑限制数据访问权限，只有机构中特定的角色可以访问。</p>
<p>第五、节点中的账本数据可以通过文件系统进行加密，节点间数据传输通过TLS进行加密。</p>
<p>Q. Do the orderers see the transaction data?</p>
<p>问题：排序节点能否看到交易数据？</p>
<p>A. No, the orderers only order transactions, they do not open the transactions.<br>If you do not want the data to go through the orderers at all, and you are only<br>concerned about the input data, then you can use visibility settings. The<br>visibility setting will determine whether input and output chaincode data is<br>included in the submitted transaction,  versus just output data. Therefore,<br>the input data can be private to the endorsers only.<br>If you do not want the orderers to see chaincode output, then you can hash or<br>encrypt the data before calling chaincode. If you hash the data then you will<br>need to provide a meansto share the source data. If you encrypt the data then<br>you will need to provide a means to share the decryption keys.</p>
<p>答案：不能，排序节点只是排序交易，不能解析交易。如果你只关心输入数据，不希望经过排序节点，你可以使用可见性设置。可见性设置将决定链码的输入输出数据是否包含在提交交易中，可以只包含输出数据，这样只有背书节点能看到输入数据。如果你不希望排序节点看到交易输出数据，你能在调用链码前对数据进行哈希操作或者加密。如果对数据进行哈希操作，你需要提供获取原数据的方式。如果对数据进行加密，你需要提供获取密钥的方式。</p>
<h2 id="Application-side-Programming-Model应用端编程模型"><a href="#Application-side-Programming-Model应用端编程模型" class="headerlink" title="Application-side Programming Model应用端编程模型"></a>Application-side Programming Model<br />应用端编程模型</h2><p><strong>Transaction execution result</strong>:</p>
<p><strong>交易执行结果</strong>:</p>
<p>Q. How do application clients know the outcome of a transaction?</p>
<p>问题：应用客户端如何知道交易的输出？</p>
<p>A. The transaction simulation results are returned to the client by the<br>endorser in the proposal response.  If there are multiple endorsers, the<br>client can check that the responses are all the same, and submit the results<br>and endorsements for ordering and commitment. Ultimately the committing peers<br>will validate or invalidate the transaction, and the client becomes<br>aware of the outcome via an event, that the SDK makes available to the<br>application client.</p>
<p>答案：背书节点会返回提案模拟交易的结果。如果有多个背书节点，客户端能检查返回结果是否相同后再提交交易结果以及排序和生效所需要的背书。最终，生效节点会验证交易是否合法，客户端通过SDK提供的事件通知方式接收交易结果。</p>
<p><strong>Ledger queries</strong>:</p>
<p><strong>账本查询</strong>:</p>
<p>Q. How do I query the ledger data?</p>
<p>问题：如何查询账本数据？</p>
<p>A. Within chaincode you can query based on keys. Keys can be queried by range,<br>and composite keys can be modeled to enable equivalence queries against multiple<br>parameters. For example a composite key of (owner,asset_id) can be used to<br>query all assets owned by a certain entity. These key-based queries can be used<br>for read-only queries against the ledger, as well as in transactions that<br>update the ledger.</p>
<p>If you model asset data as JSON in chaincode and use CouchDB as the state<br>database, you can also perform complex rich queries against the chaincode<br>data values, using the CouchDB JSON query language within chaincode. The<br>application client can perform read-only queries, but these responses are<br>not typically submitted as part of transactions to the ordering service.</p>
<p>答案：通过链码可以通过键值查询数据。可以对键值进行范围查询，复合主键可以允许查询出部分键值相同的值，例如由 (owner,asset_id) 组成的复合主键可以用来查询特定实体所拥有的所有asset。</p>
<p>Q. How do I query the historical data to understand data provenance?</p>
<p>问题：如何查询数据历史来理解数据出处？</p>
<p>A. The chaincode API <code>GetHistoryForKey()</code> will return history of<br>values for a key.</p>
<p>答案： 链码中API  <code>GetHistoryForKey()</code> 会返回键值对应的数据历史。</p>
<p>Q. How to guarantee the query result is correct, especially when the peer being<br>queried may be recovering and catching up on block processing?</p>
<p>问题：如何保证查询结果是正确的，特别是当查询的节点可能正处在恢复和获取最新区块的过程中？</p>
<p>A. The client can query multiple peers, compare their block heights, compare<br>their query results, and favor the peers at the higher block heights.</p>
<p>答案：客户端可以查询多个节点，比较他们的区块高度查询结果，选用区块高度最高的结果。</p>
<h2 id="Chaincode-Smart-Contracts-and-Digital-Assets-链码（智能合约和数字资产）"><a href="#Chaincode-Smart-Contracts-and-Digital-Assets-链码（智能合约和数字资产）" class="headerlink" title="Chaincode (Smart Contracts and Digital Assets)链码（智能合约和数字资产）"></a>Chaincode (Smart Contracts and Digital Assets)<br />链码（智能合约和数字资产）</h2><p>Q. Does Hyperledger Fabric support smart contract logic?</p>
<p>问题：Hyperledger Fabric 是否支持智能合约逻辑？</p>
<p>A. Yes. We call this feature :ref:<code>chaincode</code>. It is our interpretation of the<br>smart contract method/algorithm, with additional features.</p>
<p>A chaincode is programmatic code deployed on the network, where it is<br>executed and validated by chain validators together during the consensus<br>process. Developers can use chaincodes to develop business contracts,<br>asset definitions, and collectively-managed decentralized applications.</p>
<p>答案：是的，我们称这个功能为 :ref:<code>chaincode</code>. 这是我们对带有附加功能的智能合同方法/算法的理解。</p>
<p>链码是部署在网络中的程序代码，通过共识流程被链的验证者共同执行并验证。开发者能使用链码来开发商业合同、资产定义和集体管理的去中心化应用。</p>
<p>Q. How do I create a business contract?</p>
<p>问题：如何创建商业合同？</p>
<p>A. There are generally two ways to develop business contracts: the first way is<br>to code individual contracts into standalone instances of chaincode; the<br>second way, and probably the more efficient way, is to use chaincode to<br>create decentralized applications that manage the life cycle of one or<br>multiple types of business contracts, and let end users instantiate<br>instances of contracts within these applications.</p>
<p>答案：通常有两种方法来开发商业合同：第一个方法是开发单独的合同在独立的链码实例;第二个也是最有效的方法是使用链码创建去中心化的应用来管理一种或多种类型的商业合同的生命周期，并让终端用户实例化带有这些应用的合同实例。</p>
<p>Q. How do I create assets?</p>
<p>如何创建资产？</p>
<p>A. Users can use chaincode (for business rules) and membership service (for digital tokens) to<br>design assets, as well as the logic that manages them.</p>
<p>There are two popular approaches to defining assets in most blockchain<br>solutions: the stateless UTXO model, where account balances are encoded<br>into past transaction records; and the account model, where account<br>balances are kept in state storage space on the ledger.</p>
<p>Each approach carries its own benefits and drawbacks. This blockchain<br>technology does not advocate either one over the other. Instead, one of our<br>first requirements was to ensure that both approaches can be easily<br>implemented.</p>
<p>答案：用户可以使用链码（在商业规则方面）和成员管理服务（在数字密钥方面）来设计资产和资产管理逻辑。</p>
<p>区块链解决方案中有两种流行的方法来设计资产：无状态的UTXO模型，账户余额是过去交易记录中没有使用的交易输出的合计;另一种是账户模型，账户余额被存储在账本中的状态值中。</p>
<p>每一个方法都有好处和弊端。本区块链技术对两种方法没有倾向。我们最初的要求就是确保两个方法都能够被容易实现。</p>
<p>Q. Which languages are supported for writing chaincode?</p>
<p>问题：链码支持哪些语言？</p>
<p>A. Chaincode can be written in any programming language and executed in<br>containers.  The first fully supported chaincode language is Golang.</p>
<p>Support for additional languages and the development of a templating language<br>have been discussed, and more details will be released in the near future.</p>
<p>It is also possible to build Hyperledger Fabric applications using<br><a href="https://hyperledger.github.io/composer/" target="_blank" rel="noopener">Hyperledger Composer</a>.</p>
<p>答案：链码可以使用任何编程语言编写并在容器内执行。第一个全功能支持的语言是Golang。</p>
<p>对其他语言的支持和模板语言的开发正在被讨论，更多细节会在近期发布。</p>
<p>还可以通过<a href="https://hyperledger.github.io/composer/" target="_blank" rel="noopener">Hyperledger Composer</a>来构建Hyperledger Fabric应用。</p>
<p>Q. Does the Hyperledger Fabric have native currency?</p>
<p>问题：Hyperledger Fabric是否有原生的货币？</p>
<p>A. No. However, if you really need a native currency for your chain network,<br>you can develop your own native currency with chaincode. One common attribute<br>of native currency is that some amount will get transacted (the chaincode<br>defining that currency will get called) every time a transaction is processed<br>on its chain.</p>
<p>答案：没有。然而，如果你的区块链网络确实需要原生的货币，你可以使用链码来开发货币。原生货币的一个基本的属性是一些数量会被转移（定义货币的链码会被调用）当每次链上交易被执行。</p>
<h2 id="Differences-in-Most-Recent-Releases最近版本的区别"><a href="#Differences-in-Most-Recent-Releases最近版本的区别" class="headerlink" title="Differences in Most Recent Releases最近版本的区别"></a>Differences in Most Recent Releases<br />最近版本的区别</h2><p>Q. As part of the v1.0.0 release, what are the highlight differences between v0.6 and v1.0?</p>
<p>问题：V0.6版本和V1.0版本的最大区别是什么？</p>
<p>A. The differences between any subsequent releases are provided together with the<br><a href="http://hyperledger-fabric.readthedocs.io/en/latest/releases.html" target="_blank" rel="noopener">Release Notes</a>.<br>Since Fabric is a pluggable modular framework, you can refer to the <a href="https://wiki.hyperleger.org/projects/fabric/design-docs" target="_blank" rel="noopener">design-docs</a> for further information of these difference.</p>
<p>答案：任何后续版本的差异都在<a href="http://hyperledger-fabric.readthedocs.io/en/latest/releases.html" target="_blank" rel="noopener">版本说明</a>中展现。因为Fabric是一个模块可替换的框架，你可以参考<a href="https://wiki.hyperleger.org/projects/fabric/design-docs" target="_blank" rel="noopener">设计文档</a>获取更多差异信息。</p>
<p>Q. Where to get help for the technical questions not answered above?</p>
<p>问题：哪里可以获得上文中没被解答的技术问题的帮助？</p>
<p>A. Please use <a href="https://stackoverflow.com/questions/tagged/hyperledger" target="_blank" rel="noopener">StackOverflow</a>.</p>
<p>答案：请使用 <a href="https://stackoverflow.com/questions/tagged/hyperledger" target="_blank" rel="noopener">StackOverflow</a>.</p>
<p>.. Licensed under Creative Commons Attribution 4.0 International License</p>
<p>.. 本文通过Creative Commons Attribution 4.0 International License协议进行授权</p>
<p>   <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">https://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/13/2017-10-15-Kafka-based-Ordering-Service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tiny Hill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tiny Hill's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/13/2017-10-15-Kafka-based-Ordering-Service/" class="post-title-link" itemprop="url">[翻译]fabric区块链中启动基于卡夫卡的排序服务</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-13 17:55:00" itemprop="dateCreated datePublished" datetime="2017-10-13T17:55:00+08:00">2017-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-09 08:05:39" itemprop="dateModified" datetime="2019-11-09T08:05:39+08:00">2019-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">区块链技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>origin 原文: <a href="https://github.com/hyperledger/fabric/blob/master/docs/source/kafka.rst" target="_blank" rel="noopener">https://github.com/hyperledger/fabric/blob/master/docs/source/kafka.rst</a></p>
</blockquote>
<h2 id="Caveat-emptor-须知"><a href="#Caveat-emptor-须知" class="headerlink" title="Caveat emptor  须知"></a>Caveat emptor <br /> 须知</h2><p>This document assumes that the reader generally knows how to set up a Kafka<br>cluster and a ZooKeeper ensemble. The purpose of this guide is to identify the<br>steps you need to take so as to have a set of Hyperledger Fabric ordering<br>service nodes (OSNs) use your Kafka cluster and provide an ordering service to<br>your blockchain network.</p>
<p>该文档假设读者已经基本了解如何去搭建Kafka集群和ZooKeeper集群。本文档的目的是确定您使用Kafka集群搭建一套Hyperledger Fabric排序服务节点集(OSNs)以及为你的区块链网络提供排序服务所需要采取的步骤。</p>
<h2 id="Big-picture概览"><a href="#Big-picture概览" class="headerlink" title="Big picture概览"></a>Big picture<br />概览</h2><p>Each channel maps to a separate single-partition topic in Kafka. </p>
<p>每一个通道(channel)在Kafka中被映射到一个单独的单分区(partition)类别(topic)。(译者注：通常每个Topic包含一个或多个Partition，此处每个Topic只包含一个Partition)</p>
<p>When an OSN receives transactions via the <code>Broadcast</code> RPC, it checks to make sure<br>that the broadcasting client has permissions to write on the channel, then<br>relays (i.e. produces) those transactions to the appropriate partition in Kafka.</p>
<p>当排序节点通过RPC<code>广播</code>(<code>Broadcast</code>)接收到交易时，它会检查广播交易的客户端是否有权限去修改通道(channel)数据，然后反馈（即产生）这些交易到Kafka的适当分区(partition)中。</p>
<p>This partition is also consumed by the OSN which groups the received<br>transactions into blocks locally, persists them in its local ledger, and serves<br>them to receiving clients via the <code>Deliver</code> RPC. </p>
<p>该分区也被排序节点所消费(consume)，排序节点将接收到的交易分组写入到本地区块，将其保留在本地账本中，并通过<code>Deliver</code> RPC提供给需要接收的客户端。</p>
<p>For low-level details, refer<br>to <code>the document that describes how we came to this design
&lt;https://docs.google.com/document/d/1vNMaM7XhOlu9tB_10dKnlrhy5d7b1u8lSY8a-kVjCO4/edit&gt;</code>_<br>– Figure 8 is a schematic representation of the process described above.</p>
<p>更多详细的信息，请参考<code>the document that describes how we came to this design
&lt;https://docs.google.com/document/d/1vNMaM7XhOlu9tB_10dKnlrhy5d7b1u8lSY8a-kVjCO4/edit&gt;</code>_<br>– 图8是上述过程的示意图。</p>
<h2 id="Steps步骤"><a href="#Steps步骤" class="headerlink" title="Steps步骤"></a>Steps<br />步骤</h2><p>Let <code>K</code> and <code>Z</code> be the number of nodes in the Kafka cluster and the<br>ZooKeeper ensemble respectively:</p>
<p>设定变量 <code>K</code> 和 <code>Z</code> 分别是Kafka集群和ZooKeeper集群的节点数量：</p>
<p>i. At a minimum, <code>K</code> should be set to 4. (As we will explain in Step 4 below,<br>this is the minimum number of nodes necessary in order to exhibit crash fault<br>tolerance, i.e. with 4 brokers, you can have 1 broker go down, all channels will<br>continue to be writeable and readable, and new channels can be created.)</p>
<p>i. <code>K</code>的最小值需要是4。(我们将在步骤4中解释，这是实现 故障容错(crash fault tolerance) 所需要的最小数值，也就是说，<br>4个节点可以容许1个节点宕机，所有的通道能够继续读写且可以创建通道。)(译者：Kafka节点被称为broker)</p>
<p>ii. <code>Z</code> will either be 3, 5, or 7. It has to be an odd number to avoid<br>split-brain scenarios, and larger than 1 in order to avoid single point of<br>failures. Anything beyond 7 ZooKeeper servers is considered an overkill.</p>
<p>ii. <code>Z</code>可以是3、5或者7。它必须是一个奇数来避免分裂(split-brain)情景，大于1以避免单点故障。<br>超过7个ZooKeeper服务器则被认为是多余的。</p>
<p>Proceed as follows:</p>
<p>请按照以下步骤进行:</p>
<ol>
<li><p>Orderers: <strong>Encode the Kafka-related information in the network’s genesis<br>block.</strong> If you are using <code>configtxgen</code>, edit <code>configtx.yaml</code> – or pick a<br>preset profile for the system channel’s genesis block –  so that:</p>
<p>Orderers: <strong>Kafka 相关信息被写在网络的初始区块中.</strong> 如果你使用 <code>configtxgen</code> 工具, 编辑 <code>configtx.yaml</code> 文件– 或者挑一个现成的系统通道的初始区块配置文件 –  其中:</p>
<p> a. <code>Orderer.OrdererType</code> is set to <code>kafka</code>.</p>
<p> a. <code>Orderer.OrdererType</code> 字段被设置为 <code>kafka</code>.</p>
<p> b. <code>Orderer.Kafka.Brokers</code> contains the address of <em>at least two</em> of the<br> Kafka brokers in your cluster in <code>IP:port</code> notation. The list does not<br> need to be exhaustive. (These are your seed brokers.)</p>
<p> b. <code>Orderer.Kafka.Brokers</code> 字段包含 <em>至少两个</em> Kafka集群中的节点<code>IP:port</code> 样式的地址。这个列表没有必要详尽无遗(这些是你的 seed brokers.)</p>
</li>
<li><p>Orderers: <strong>Set the maximum block size.</strong> Each block will have at most<br><code>Orderer.AbsoluteMaxBytes</code> bytes (not including headers), a value that you can<br>set in <code>configtx.yaml</code>. Let the value you pick here be <code>A</code> and make note of<br>it – it will affect how you configure your Kafka brokers in Step 4.</p>
<p>Orderers: <strong>设置区块最大容量.</strong> 每一个区块最多只能有 <code>Orderer.AbsoluteMaxBytes</code> bytes的容量(不含区块头信息), 这是一个你可以修改的值，存放在 <code>configtx.yaml</code> 配置文件中. 假设此处你设置的数值为<code>A</code>,将此数字记下来 – 这会影响你在步骤4中对于Kafka brokers 的配置.</p>
</li>
<li><p>Orderers: <strong>Create the genesis block.</strong> Use <code>configtxgen</code>. The settings you<br>picked in Steps 1 and 2 above are system-wide settings, i.e. they apply across<br>the network for all the OSNs. Make note of the genesis block’s location.</p>
<p>Orderers:  使用 <code>configtxgen</code> 工具 <strong>创建初始区块.</strong> 在步骤1和2中的设置是全局的设置, 也就是说这些设置的生效范围是网络中所有的排序节点. 记录下初始区块的位置. </p>
</li>
<li><p>Kafka cluster: <strong>Configure your Kafka brokers appropriately.</strong> Ensure that<br>every Kafka broker has these keys configured:</p>
<p>Kafka 集群: <strong>适当配置你的Kafka集群.</strong> 确保每一个Kafka节点都配置了以下的值:</p>
<p> a. <code>unclean.leader.election.enable = false</code> – Data consistency is key in<br> a blockchain environment. We cannot have a channel leader chosen outside of<br> the in-sync replica set, or we run the risk of overwriting the offsets that<br> the previous leader produced, and –as a result– rewrite the blockchain<br> that the orderers produce.</p>
<p> a. <code>unclean.leader.election.enable = false</code> – 数据一致性是区块链环境的关键. 我们不能选择不在同步副本集中的channel leader, 也不能冒风险去覆盖前一leader所产生的偏移量, 那样的结果就是重写orderers所产生的区块链数据.</p>
<p> b.  <code>min.insync.replicas = M</code> – Where you pick a value <code>M</code> such that<br> 1 &lt; M &lt; N (see <code>default.replication.factor</code> below). Data is considered<br> committed when it is written to at least <code>M</code> replicas (which are then<br> considered in-sync and belong to the in-sync replica set, or ISR). In any<br> other case, the write operation returns an error. Then:</p>
<p> b.  <code>min.insync.replicas = M</code> –  <code>M</code> 的值需要满足<br> 1 &lt; M &lt; N (N的值参考后面的 <code>default.replication.factor</code>). 数据被认为是完成提交当它被写入到至少 <code>M</code> 个副本中(也就是说它被认为是同步的,然后被写入到同步副本集中,也成为ISR). 其他情况, 写入操作返回错误信息. 然后: </p>
<pre><code>i. If up to N-M replicas -- out of the N that the channel data is
written to -- become unavailable, operations proceed normally.
i. 如果有 N-M 个副本不可访问, 操作将正常进行.
ii. If more replicas become unavailable, Kafka cannot maintain an ISR
set of M, so it stops accepting writes. Reads work without issues.
The channel becomes writeable again when M replicas get in-sync.
ii. 如果更多副本不可访问, Kafka 不能位置数量 M 的同步副本集(ISR), 所以它会停止接受写入操作. 读操作可以正常运行.
当M个副本重新同步后,通道就可以再次变为可写入状态.</code></pre></li>
</ol>
<pre><code>c. ``default.replication.factor = N`` -- Where you pick a value ``N`` such
that N &lt; K. A replication factor of ``N`` means that each channel will have
its data replicated to ``N`` brokers. These are the candidates for the ISR
set of a channel. As we noted in the ``min.insync.replicas section`` above,
not all of these brokers have to be available all the time. ``N`` should be
set *strictly smaller* to ``K`` because channel creations cannot go forward
if less than ``N`` brokers are up. So if you set N = K, a single broker
going down means that no new channels can be created on the blockchain
network -- the crash fault tolerance of the ordering service is
non-existent.

c. ``default.replication.factor = N`` -- 选择一个 ``N`` 的数值满足 N &lt; K (Kafak集群数量). 参数 ``N`` 表示每个channel 的数据会复制到 ``N`` 个 broker 中. 这些是 channel 同步副本集的候选. 正如前面 ``min.insync.replicas`` 部分所说的, 不是所有broker都需要是随时可用的. ``N`` 值需要设置为绝对小于 ``K`` , 因为channel的创建需要不少于 ``N`` 个broker是启动的. 所以如果设置 N = K , 一个 broker 宕机就意味着区块链网络不能再创建channel. 那么故障容错的排序服务也就不存在了.


d. ``message.max.bytes`` and ``replica.fetch.max.bytes`` should be set to a
value larger than ``A``, the value you picked in
``Orderer.AbsoluteMaxBytes`` in Step 2 above. Add some buffer to account for
headers -- 1 MiB is more than enough. The following condition applies:

d. ``message.max.bytes`` 和 ``replica.fetch.max.bytes`` 的值需要大于 ``A``, 就是在步骤2中选取的 ``Orderer.AbsoluteMaxBytes`` 的值. 再为区块头增加一些余量 -- 1 MiB 就足够了. 需要满足以下条件:

::

    Orderer.AbsoluteMaxBytes &lt; replica.fetch.max.bytes &lt;= message.max.bytes

(For completeness, we note that ``message.max.bytes`` should be strictly
smaller to ``socket.request.max.bytes`` which is set by default to 100 MiB.
If you wish to have blocks larger than 100 MiB you will need to edit the
hard-coded value in ``brokerConfig.Producer.MaxMessageBytes`` in
``fabric/orderer/kafka/config.go`` and rebuild the binary from source.
This is not advisable.)

(补充, 我们注意到 ``message.max.bytes`` 需要严格小于 ``socket.request.max.bytes`` , 这个值默认是100Mib. 如果你希望区块大于100MiB, 你需要去修改硬代码中的变量 ``brokerConfig.Producer.MaxMessageBytes`` , 代码位置是 ``fabric/orderer/kafka/config.go`` , 再重新编译代码, 不建议这么做.)

e. ``log.retention.ms = -1``. Until the ordering service adds
support for pruning of the Kafka logs, you should disable time-based
retention and prevent segments from expiring. (Size-based retention -- see
``log.retention.bytes`` -- is disabled by default in Kafka at the time of
this writing, so there&apos;s no need to set it explicitly.)

e. ``log.retention.ms = -1``. 直到排序服务增加了对于 Kafka 日志分割(pruning)的支持之前, 应该禁用基于时间分割的方式以避免单个日志文件到期分段. (基于文件大小的分割方式 -- 看参数 ``log.retention.bytes`` -- 在本文书写时, 在 Kafka 中是默认被禁用的, 所以这个值没有必要指定地很明确. )

Based on what we&apos;ve described above, the minimum allowed values for ``M``
and ``N`` are 2 and 3 respectively. This configuration allows for the
creation of new channels to go forward, and for all channels to continue to
be writeable.

基于上文所描述的, ``M`` 和 ``N`` 的最小值分别为 2 和 3 . 这个配置可以创建 channel 并让所有 channel 都是随时可以写入的.</code></pre><ol start="5">
<li><p>Orderers: <strong>Point each OSN to the genesis block.</strong> Edit<br><code>General.GenesisFile</code> in <code>orderer.yaml</code> so that it points to the genesis<br>block created in Step 3 above. (While at it, ensure all other keys in that YAML<br>file are set appropriately.)</p>
<p>Orderers: <strong>将所有排序节点指向初始区块.</strong> 编辑 <code>orderer.yaml</code> 文件中的参数 <code>General.GenesisFile</code> 使其指向步骤3中所创建的初始区块. (同时, 确保YAML文件中所有其他参数都是正确的.)</p>
</li>
<li><p>Orderers: <strong>Adjust polling intervals and timeouts.</strong> (Optional step.)<br>Orderers: <strong>调整轮询间隔和超时时间.</strong> (可选步骤.)</p>
<p> a. The <code>Kafka.Retry</code> section in the <code>orderer.yaml</code> file allows you to<br> adjust the frequency of the metadata/producer/consumer requests, as well as<br> the socket timeouts. (These are all settings you would expect to see in a<br> Kafka producer or consumer.)</p>
<p> a.  <code>orderer.yaml</code> 文件中的 <code>Kafka.Retry</code> 区域让你能够调整  metadata/producer/consumer 请求的频率以及socket的超时时间. (这些应该就是所有在 kafka 的生产者和消费者 中你需要的设置)</p>
<p> b. Additionally, when a new channel is created, or when an existing channel<br> is reloaded (in case of a just-restarted orderer), the orderer interacts<br> with the Kafka cluster in the following ways:</p>
<p> b. 另外, 当一个 channel 被创建, 或当一个现有的 channel 被重新读取(刚启动 orderer 的情况), orderer 通过以下方式和 Kafka 集群进行交互. </p>
<pre><code>a. It creates a Kafka producer (writer) for the Kafka partition that
corresponds to the channel.

a. 为 channel 对应的 Kafka 分区 创建一个 Kafka 生产者.

b. It uses that producer to post a no-op ``CONNECT`` message to that
partition.

b. 通过生产者向这个分区发一个空的连接信息.

c. It creates a Kafka consumer (reader) for that partition.

c. 为这个分区创建一个 Kafka 消费者. 

If any of these steps fail, you can adjust the frequency with which they
are repeated. Specifically they will be re-attempted every
``Kafka.Retry.ShortInterval`` for a total of ``Kafka.Retry.ShortTotal``,
and then every ``Kafka.Retry.LongInterval`` for a total of
``Kafka.Retry.LongTotal`` until they succeed. Note that the orderer will
be unable to write to or read from a channel until all of the steps
above have been completed successfully.

如果任意步骤出错, 你可以调整其重复的频率. 
这些步骤会在每一个 Kafka.Retry.ShortInterval 指定的时间间隔后进行重试 Kafka.Retry.ShortTotal 次, 
再以 Kafka.Retry.LongInterval 规定的时间间隔重试 Kafka.Retry.LongTotal 次直到成功. 
需要注意的是 orderer 不能读写该 channel 的数据直到所有上述步骤都成功执行.</code></pre></li>
<li><p><strong>Set up the OSNs and Kafka cluster so that they communicate over SSL.</strong><br>(Optional step, but highly recommended.) Refer to <code>the Confluent guide
&lt;http://docs.confluent.io/2.0.0/kafka/ssl.html&gt;</code>_ for the Kafka cluster side of<br>the equation, and set the keys under <code>Kafka.TLS</code> in <code>orderer.yaml</code> on every<br>OSN accordingly.</p>
<p><strong>将排序节点和 Kafka 集群间设置为通过 SSL 通讯.</strong><br>(可选步骤,强烈推荐) 参考 <code>the Confluent guide
&lt;http://docs.confluent.io/2.0.0/kafka/ssl.html&gt;</code>_ 文档中关于 Kafka 集群的设置, 来设置每个排序节点 <code>orderer.yaml</code> 文件中  <code>Kafka.TLS</code> 部分的内容.</p>
</li>
<li><p><strong>Bring up the nodes in the following order: ZooKeeper ensemble, Kafka<br>cluster, ordering service nodes.</strong></p>
<p><strong>启动节点请按照以下顺序: ZooKeeper 集群, Kafka 集群, 排序节点</strong></p>
</li>
</ol>
<h2 id="Additional-considerations其他注意事项"><a href="#Additional-considerations其他注意事项" class="headerlink" title="Additional considerations其他注意事项"></a>Additional considerations<br />其他注意事项</h2><ol>
<li><p><strong>Preferred message size.</strong> In Step 2 above (see <code>Steps</code>_ section) you can<br>also set the preferred size of blocks by setting the<br><code>Orderer.Batchsize.PreferredMaxBytes</code> key. Kafka offers higher throughput when<br>dealing with relatively small messages; aim for a value no bigger than 1 MiB.</p>
<p><strong>首选的消息大小.</strong> 在上面的步骤2中, 你也能通过参数 <code>Orderer.Batchsize.PreferredMaxBytes</code> 设置首选的区块大小.<br>Kafka 处理相对较小的信息有更高的吞吐量; 针对小于 1 MiB 大小的值.</p>
</li>
<li><p><strong>Using environment variables to override settings.</strong> You can override a<br>Kafka broker or a ZooKeeper server’s settings by using environment variables.<br>Replace the dots of the configuration key with underscores –<br>e.g. <code>KAFKA_UNCLEAN_LEADER_ELECTION_ENABLE=false</code> will allow you to override<br>the default value of <code>unclean.leader.election.enable</code>. The same applies to the<br>OSNs for their <em>local</em> configuration, i.e. what can be set in <code>orderer.yaml</code>.<br>For example <code>ORDERER_KAFKA_RETRY_SHORTINTERVAL=1s</code> allows you to override the<br>default value for <code>Orderer.Kafka.Retry.ShortInterval</code>.</p>
<p><strong>使用环境变量重写设置.</strong> 你能够通过设置环境变量来重写 Kafka 节点和 Zookeeper 服务器的设置. 替换配置参数中的 点 为 下划线 – 例如 <code>KAFKA_UNCLEAN_LEADER_ELECTION_ENABLE=false</code> 环境变量重写配置参数 <code>unclean.leader.election.enable</code>. 环境变量重写同样适用于排序节点的<em>本地</em>配置, 即 <code>orderer.yaml</code> 中所能设置的. 例如 <code>ORDERER_KAFKA_RETRY_SHORTINTERVAL=1s</code> 环境变量可以重写本地配置文件中的 <code>Orderer.Kafka.Retry.ShortInterval</code>.</p>
</li>
</ol>
<h2 id="Supported-Kafka-versions-and-upgrading支持的-Kafka-版本和升级"><a href="#Supported-Kafka-versions-and-upgrading支持的-Kafka-版本和升级" class="headerlink" title="Supported Kafka versions and upgrading支持的 Kafka 版本和升级"></a>Supported Kafka versions and upgrading<br />支持的 Kafka 版本和升级</h2><p>Supported Kafka versions for v1 are <code>0.9</code> and <code>0.10</code>. (Hyperledger Fabric<br>uses the <code>sarama client library &lt;https://github.com/Shopify/sarama&gt;</code>_<br>and vendors a version of it that supports Kafka 0.9 and 0.10.)</p>
<p>Fabric V1 支持的 Kafka 版本是 <code>0.9</code> 和 <code>0.10</code>. (Hyperledger Fabric 使用代码库: <code>sarama client library &lt;https://github.com/Shopify/sarama&gt;</code>_ 支持的 Kafka 版本是 <code>0.9</code> 和 <code>0.10</code>)</p>
<p>Out of the box the Kafka version defaults to <code>0.9.0.1</code>. If you wish to use a<br>different supported version, specify a supported version using the<br><code>Kafka.Version</code> key in <code>orderer.yaml</code>.</p>
<p>默认的 Kafka 版本是 <code>0.9.0.1</code>. 如果你使用其他支持的版本, 修改 <code>orderer.yaml</code> 文件中的参数 <code>Kafka.Version</code>.</p>
<p>The current supported Kafka versions are:</p>
<p>目前支持的 Kafka 版本是:</p>
<ul>
<li><code>Version: 0.9.0.1</code></li>
<li><code>Version: 0.10.0.0</code></li>
<li><code>Version: 0.10.0.1</code></li>
<li><code>Version: 0.10.1.0</code></li>
</ul>
<h2 id="Debugging调试"><a href="#Debugging调试" class="headerlink" title="Debugging调试"></a>Debugging<br />调试</h2><p>Set <code>General.LogLevel</code> to <code>DEBUG</code> and <code>Kafka.Verbose</code> in <code>orderer.yaml</code><br>to <code>true</code>.</p>
<p>设置 <code>orderer.yaml</code> 文件中 <code>General.LogLevel</code> 为 <code>DEBUG</code> 和 <code>Kafka.Verbose</code> 为 <code>true</code>.</p>
<h2 id="Example例子"><a href="#Example例子" class="headerlink" title="Example例子"></a>Example<br />例子</h2><p>Sample Docker Compose configuration files inline with the recommended settings<br>above can be found under the <code>fabric/bddtests</code> directory. Look for<br><code>dc-orderer-kafka-base.yml</code> and <code>dc-orderer-kafka.yml</code>.</p>
<p>包含了推荐的设置的Docker Compose 配置文件示例能够在 <code>fabric/bddtests</code> 目录中找到. 包括 <code>dc-orderer-kafka-base.yml</code> 文件和 <code>dc-orderer-kafka.yml</code> 文件.</p>
<p>.. Licensed under Creative Commons Attribution 4.0 International License<br>   <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">https://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/13/2017-10-13-configtxlator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Tiny Hill">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tiny Hill's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/10/13/2017-10-13-configtxlator/" class="post-title-link" itemprop="url">[翻译]使用configtxlator工具重新配置fabric区块链</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-10-13 17:55:00" itemprop="dateCreated datePublished" datetime="2017-10-13T17:55:00+08:00">2017-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-09 08:05:44" itemprop="dateModified" datetime="2019-11-09T08:05:44+08:00">2019-11-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">区块链技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>original：<a href="https://github.com/hyperledger/fabric/blob/master/docs/source/configtxlator.rst" target="_blank" rel="noopener">https://github.com/hyperledger/fabric/blob/master/docs/source/configtxlator.rst</a></p>
<h2 id="Overview概览"><a href="#Overview概览" class="headerlink" title="Overview概览"></a>Overview<br />概览</h2><p>The <code>configtxlator</code> tool was created to support reconfiguration independent<br>of SDKs. Channel configuration is stored as a transaction in configuration<br>blocks of a channel and may be manipulated directly, such as in the bdd behave<br>tests. However, at the time of this writing, no SDK natively supports<br>manipulating the configuration directly, so the <code>configtxlator</code> tool is<br>designed to provide an API which consumers of any SDK may interact with to<br>assist with configuration updates.</p>
<p>开发 <code>configtxlator</code> 工具是为了支持独立于 SDK 来进行重新配置。通道配置通过一个交易的形式存储在通道的配置区块中，并且能够直接被修改，就像 bdd 行为测试。<br>然而，在本文写作的时间，还没有 SDK 原生支持直接修改配置，所以 <code>configtxlator</code> 工具被设计为提供一个 API 让任意一个 SDK 的用户都能够与之交互来更新配置。</p>
<p>The tool name is a portmanteau of <em>configtx</em> and <em>translator</em> and is intended to<br>convey that the tool simply converts between different equivalent data<br>representations. It does not generate configuration. It does not submit or<br>retrieve configuration. It does not modify configuration itself, it simply<br>provides some bijective operations between different views of the configtx<br>format.</p>
<p>工具的名称是 <em>configtx</em> 和 <em>translator</em> 的拼接，意在传达该工具简单地在不同的等效数据之间进行转换。<br>它不产生配置。也不提交或撤回配置。它不修改配置本身，只是简单地提供一些配置格式的不同的双射展现。</p>
<p>译者注：既是单射又是满射的函数称为双射. 函数为双射当且仅当每个可能的像有且仅有一个变量与之对应。参考：<a href="http://www.cnblogs.com/wanghetao/archive/2012/03/16/2400619.html" target="_blank" rel="noopener">http://www.cnblogs.com/wanghetao/archive/2012/03/16/2400619.html</a></p>
<p>The standard usage is expected to be:</p>
<ol>
<li>SDK retrieves latest config</li>
<li><code>configtxlator</code> produces human readable version of config</li>
<li>User or application edits the config</li>
<li><code>configtxlator</code> is used to compute config update representation of<br>changes to the config</li>
<li>SDK submits signs and submits config</li>
</ol>
<p>标准用法：</p>
<ol>
<li>SDK 取出最新的配置</li>
<li><code>configtxlator</code> 工具产生可读版本的配置文件</li>
<li>用户或者应用编辑配置文件</li>
<li>使用 <code>configtxlator</code> 工具计算更新的配置与原有配置的差异</li>
<li>SDK 提交配置以及签名</li>
</ol>
<p>The <code>configtxlator</code> tool exposes a truly stateless REST API for interacting<br>with configuration elements. These REST components support converting the<br>native configuration format to/from a human readable JSON representation, as<br>well as computing configuration updates based on the difference between two<br>configurations.</p>
<p><code>configtxlator</code> 工具暴露一个完全无状态的 REST API 接口用来和配置匀速进行交互。<br>这些 REST 组件支持本地的配置和可读的 JSON 格式配置文件进行相互转换， 同时根据配置文件的差异计算配置的更新。</p>
<p>Because the <code>configtxlator</code> service deliberately does not contain any crypto<br>material, or otherwise secret information, it does not include any authorization<br>or access control. The anticipated typical deployment would be to operate as<br>a sandboxed container, locally with the application, so that there is a<br>dedicated <code>configtxlator</code> process for each consumer of it.</p>
<p>因为 <code>configtxlator</code> 工具特意没有包含任何密码工具和密钥信息， 所有它没有任何权限控制。<br>预计的典型部署方式是运行在沙盒容器中， 所以在本地的应用中， 有一个专用的 <code>configtxlator</code> 进程给每一个使用者。</p>
<h2 id="Running-the-configtxlator运行-configtxlator-工具"><a href="#Running-the-configtxlator运行-configtxlator-工具" class="headerlink" title="Running the configtxlator运行 configtxlator 工具"></a>Running the configtxlator<br />运行 configtxlator 工具</h2><p>The <code>configtxlator</code> tool can be downloaded with the other Hyperledger Fabric<br>platform-specific binaries. Please see :ref:<code>download-platform-specific-binaries</code><br>for details.</p>
<p><code>configtxlator</code> 工具可以和其他 Hyperledger Fabric 平台专用工具一样被下载使用。详情请查看 ref:<code>download-platform-specific-binaries</code> 。</p>
<p>The tool may be configured to listen on a different port and you may also<br>specify the hostname using the <code>--port</code> and <code>--hostname</code> flags. To explore<br>the complete set of commands and flags, run <code>configtxlator --help</code>.</p>
<p>该工具可以配置去监听不同的端口和地址，只用 <code>--port</code> 和 <code>--hostname</code> 参数。<br>查看所有参数的详细信息，执行 <code>configtxlator --help</code>.</p>
<p>The binary will start an http server listening on the designated port and is now<br>ready to process request.</p>
<p>工具启动一个服务器监听指定的端口且等待处理请求。</p>
<p>To start the <code>configtxlator</code> server:</p>
<p>执行命令启动 <code>configtxlator</code> 服务：</p>
<p>.. code:: bash</p>
<p>configtxlator start<br>2017-06-21 18:16:58.248 HKT [configtxlator] startServer -&gt; INFO 001 Serving HTTP requests on 0.0.0.0:7059</p>
<h2 id="Proto-translation原型翻译"><a href="#Proto-translation原型翻译" class="headerlink" title="Proto translation原型翻译"></a>Proto translation<br />原型翻译</h2><p>For extensibility, and because certain fields must be signed over, many proto<br>fields are stored as bytes. This makes the natural proto to JSON translation<br>using the <code>jsonpb</code> package ineffective for producing a human readable version<br>of the protobufs. Instead, the <code>configtxlator</code> exposes a REST component to do<br>a more sophisticated translation.</p>
<p>为了可扩展性，以及特定的字段需要被签名，许多原型字段被存储为字节。使用 <code>jsonpb</code> 工具包来转换原型和可读的 JSON 格式因此变得无效。<br>替代的方式是， <code>configtxlator</code> 暴露一个 REST 组件去做更复杂的翻译。</p>
<p>To convert a proto to its human readable JSON equivalent, simply post the binary<br>proto to the rest target<br><code>http://$SERVER:$PORT/protolator/decode/&lt;message.Name&gt;</code>,<br>where <code>&lt;message.Name&gt;</code> is the fully qualified proto name of the message.</p>
<p>要转换原型到可读的 JSON 格式，只要发送二进制原型到 rest 目标<br><code>http://$SERVER:$PORT/protolator/decode/&lt;message.Name&gt;</code>,<br><code>&lt;message.Name&gt;</code> 是合法原型名的全称。</p>
<p>For instance, to decode a configuration block saved as<br><code>configuration_block.pb</code>, run the command:</p>
<p>例如，为了解析一个存储为 <code>configuration_block.pb</code> 的配置区块，执行命令：</p>
<p>.. code:: bash</p>
<p>curl -X POST –data-binary @configuration_block.pb <a href="http://127.0.0.1:7059/protolator/decode/common.Block" target="_blank" rel="noopener">http://127.0.0.1:7059/protolator/decode/common.Block</a></p>
<p>To convert the human readable JSON version of the proto message, simply post the<br>JSON version to <code>http://$SERVER:$PORT/protolator/encode/&lt;message.Name</code>, where<br><code>&lt;message.Name&gt;</code> is again the fully qualified proto name of the message.</p>
<p>转换可读的 JSON 版本为原型数据，只要发送 JSON 版本到 <code>http://$SERVER:$PORT/protolator/encode/&lt;message.Name&gt;</code> ，<br>这里的 <code>&lt;message.Name&gt;</code> 是合法原型的全称。</p>
<p>For instance, to re-encode the block saved as <code>configuration_block.json</code>, run<br>the command:</p>
<p>例如，重新编码存储为 <code>configuration_block.json</code> 的配置区块，执行命令：</p>
<p>.. code:: bash</p>
<p>curl -X POST –data-binary @configuration_block.json <a href="http://127.0.0.1:7059/protolator/encode/common.Block" target="_blank" rel="noopener">http://127.0.0.1:7059/protolator/encode/common.Block</a></p>
<p>Any of the configuration related protos, including <code>common.Block</code>,<br><code>common.Envelope</code>, <code>common.ConfigEnvelope</code>, <code>common.ConfigUpdateEnvelope</code>,<br><code>common.Configuration</code>, and <code>common.ConfigUpdate</code> are valid targets for<br>these URLs. In the future, other proto decoding types may be added, such as<br>for endorser transactions.</p>
<p>任何原型相关的配置，包括 <code>common.Block</code>,<br><code>common.Envelope</code>, <code>common.ConfigEnvelope</code>, <code>common.ConfigUpdateEnvelope</code>,<br><code>common.Configuration</code>, 和 <code>common.ConfigUpdate</code> 都是这些地址的合法的目标。<br>未来，其他解析类型可能会被增加，比如背书交易。</p>
<h2 id="Config-update-computation配置更新计算"><a href="#Config-update-computation配置更新计算" class="headerlink" title="Config update computation配置更新计算"></a>Config update computation<br />配置更新计算</h2><p>Given two different configurations, it is possible to compute the config update<br>which transitions between them. Simply POST the two <code>common.Config</code> proto<br>encoded configurations as <code>multipart/formdata</code>, with the original as field<br><code>original</code> and the updated as field <code>updated</code>, to<br><code>http://$SERVER:$PORT/configtxlator/compute/update-from-configs</code>.</p>
<p>两个不同的配置，可以计算出两个配置更新所需要的交易。<br>向 <code>http://$SERVER:$PORT/configtxlator/compute/update-from-configs``  
发送两个已编码的</code>common.Config<code>原型配置作为</code>multipart/formdata<code>，其中原始配置填入</code>original<code>域，更新配置填入</code>updated` 域。</p>
<p>For example, given the original config as the file <code>original_config.pb</code> and<br>the updated config as the file <code>updated_config.pb</code> for the channel<br><code>desiredchannel</code>:</p>
<p>例如，对于通道 <code>desiredchannel</code> 的原始配置文件 <code>original_config.pb</code> 和更新配置文件 <code>updated_config.pb</code> ：</p>
<p>.. code:: bash</p>
<p>curl -X POST -F channel=desiredchannel -F original=@original_config.pb -F updated=@updated_config.pb <a href="http://127.0.0.1:7059/configtxlator/compute/update-from-configs" target="_blank" rel="noopener">http://127.0.0.1:7059/configtxlator/compute/update-from-configs</a></p>
<h2 id="Bootstraping-example引导实例"><a href="#Bootstraping-example引导实例" class="headerlink" title="Bootstraping example引导实例"></a>Bootstraping example<br />引导实例</h2><p>First start the <code>configtxlator</code>:</p>
<p>首先，启动启动 <code>configtxlator</code> 工具:</p>
<p>.. code:: bash</p>
<p>$ configtxlator start<br>2017-05-31 12:57:22.499 EDT [configtxlator] main -&gt; INFO 001 Serving HTTP requests on port: 7059</p>
<p>First, produce a genesis block for the ordering system channel:</p>
<p>然后，为通道产生初始区块</p>
<p>.. code:: bash</p>
<p>$ configtxgen -outputBlock genesis_block.pb<br>2017-05-31 14:15:16.634 EDT [common/configtx/tool] main -&gt; INFO 001 Loading configuration<br>2017-05-31 14:15:16.646 EDT [common/configtx/tool] doOutputBlock -&gt; INFO 002 Generating genesis block<br>2017-05-31 14:15:16.646 EDT [common/configtx/tool] doOutputBlock -&gt; INFO 003 Writing genesis block</p>
<p>Decode the genesis block into a human editable form:</p>
<p>解析初始区块为可编辑的形式</p>
<p>.. code:: bash</p>
<p>curl -X POST –data-binary @genesis_block.pb <a href="http://127.0.0.1:7059/protolator/decode/common.Block" target="_blank" rel="noopener">http://127.0.0.1:7059/protolator/decode/common.Block</a> &gt; genesis_block.json</p>
<p>Edit the <code>genesis_block.json</code> file in your favorite JSON editor, or manipulate<br>it programatically. Here we use the JSON CLI tool <code>jq</code>. For simplicity, we<br>are editing the batch size for the channel, because it is a single numeric<br>field. However, any edits, including policy and MSP edits may be made here.</p>
<p>使用你喜欢的 JSON 编辑器编辑 <code>genesis_block.json</code> 文件，或使用程序编辑。 这里需要使用 JSON 工具 <code>jq</code> .<br>为了方便，这里编辑通道的区块大小，因为这是一个数字字段。<br>然而，任何修改，包括策略和 MSP 都是可以做的。</p>
<p>First, let’s establish an environment variable to hold the string that defines<br>the path to a property in the json:</p>
<p>首先，建立一个环境变量来存储变量的路径</p>
<p>.. code:: bash</p>
<p>export MAXBATCHSIZEPATH=”.data.data[0].payload.data.config.channel_group.groups.Orderer.values.BatchSize.value.max_message_count”</p>
<p>Next, let’s display the value of that property:</p>
<p>然后，显示变量的值</p>
<p>.. code:: bash</p>
<p>jq “$MAXBATCHSIZEPATH” genesis_block.json<br>10</p>
<p>Now, let’s set the new batch size, and display the new value:</p>
<p>现在，设置新的区块大小，并且显示新值：</p>
<p>jq “$MAXBATCHSIZEPATH = 20” genesis_block.json  &gt; updated_genesis_block.json<br>  jq “$MAXBATCHSIZEPATH” updated_genesis_block.json<br>20</p>
<p>The genesis block is now ready to be re-encoded into the native proto form to be<br>used for bootstrapping:</p>
<p>初始区块现在已经可以被重新编码为可用于引导启动的原型格式：</p>
<p>.. code:: bash</p>
<p>curl -X POST –data-binary @updated_genesis_block.json <a href="http://127.0.0.1:7059/protolator/encode/common.Block" target="_blank" rel="noopener">http://127.0.0.1:7059/protolator/encode/common.Block</a> &gt; updated_genesis_block.pb</p>
<p>The <code>updated_genesis_block.pb</code> file may now be used as the genesis block for<br>bootstrapping an ordering system channel.</p>
<p>现在， <code>updated_genesis_block.pb</code> 文件可以作为初始区块来引导通道启动了。</p>
<h2 id="Reconfiguration-example重配置示例"><a href="#Reconfiguration-example重配置示例" class="headerlink" title="Reconfiguration example重配置示例"></a>Reconfiguration example<br />重配置示例</h2><p>In another terminal window, start the orderer using the default options,<br>including the provisional bootstrapper which will create a <code>testchainid</code><br>ordering system channel.</p>
<p>打开另一个终端窗口，使用默认选项启动 orderer，<br>包括临时的引导程序，将会创建一个名称为 <code>testchainid</code> 的排序通道。</p>
<p>.. code:: bash</p>
<p>ORDERER_GENERAL_LOGLEVEL=debug orderer</p>
<p>Reconfiguring a channel can be performed in a very similar way to modifying a<br>genesis config.</p>
<p>重配置一个通道与修改初始配置类似。</p>
<p>First, fetch the config_block proto:</p>
<p>首先，获取配置区块原型：</p>
<p>.. code:: bash</p>
<p>$ peer channel fetch config config_block.pb -o 127.0.0.1:7050 -c testchainid<br>2017-05-31 15:11:37.617 EDT [msp] getMspConfig -&gt; INFO 001 intermediate certs folder not found at [/home/yellickj/go/src/github.com/hyperledger/fabric/sampleconfig/msp/intermediatecerts]. Skipping.: [stat /home/yellickj/go/src/github.com/hyperledger/fabric/sampleconfig/msp/intermediatecerts: no such file or directory]<br>2017-05-31 15:11:37.617 EDT [msp] getMspConfig -&gt; INFO 002 crls folder not found at [/home/yellickj/go/src/github.com/hyperledger/fabric/sampleconfig/msp/intermediatecerts]. Skipping.: [stat /home/yellickj/go/src/github.com/hyperledger/fabric/sampleconfig/msp/crls: no such file or directory]<br>Received block: 1<br>Received block: 1<br>2017-05-31 15:11:37.635 EDT [main] main -&gt; INFO 003 Exiting…..</p>
<p>Next, send the config block to the <code>configtxlator</code> service for decoding:</p>
<p>然后，发送配置区块到 <code>configtxlator</code> 服务进行解析：</p>
<p>.. code:: bash</p>
<p>curl -X POST –data-binary @config_block.pb <a href="http://127.0.0.1:7059/protolator/decode/common.Block" target="_blank" rel="noopener">http://127.0.0.1:7059/protolator/decode/common.Block</a> &gt; config_block.json</p>
<p>Extract the config section from the block:</p>
<p>从区块中提取配置区域</p>
<p>.. code:: bash</p>
<p>jq .data.data[0].payload.data.config config_block.json &gt; config.json</p>
<p>Edit the config, saving it as a new <code>updated_config.json</code>. Here, we set the<br>batch size to 30.</p>
<p>编辑配置，将编辑后的内容存放在 <code>updated_config.json</code> 。这里我们设计区块大小为 30.</p>
<p>.. code:: bash</p>
<p>jq “.channel_group.groups.Orderer.values.BatchSize.value.max_message_count = 30” config.json &gt; updated_config.json</p>
<p>Re-encode both the original config, and the updated config into proto:</p>
<p>重新将原配置与新配置进行编码：</p>
<p>.. code:: bash</p>
<p>curl -X POST –data-binary @config.json <a href="http://127.0.0.1:7059/protolator/encode/common.Config" target="_blank" rel="noopener">http://127.0.0.1:7059/protolator/encode/common.Config</a> &gt; config.pb</p>
<p>.. code:: bash</p>
<p>curl -X POST –data-binary @updated_config.json <a href="http://127.0.0.1:7059/protolator/encode/common.Config" target="_blank" rel="noopener">http://127.0.0.1:7059/protolator/encode/common.Config</a> &gt; updated_config.pb</p>
<p>Now, with both configs properly encoded, send them to the <code>configtxlator</code><br>service to compute the config update which transitions between the two.</p>
<p>现在，将编码后的文件发送到 <code>configtxlator</code> 服务进行计算比对两个的差异。</p>
<p>.. code:: bash</p>
<p>curl -X POST -F original=@config.pb -F updated=@updated_config.pb <a href="http://127.0.0.1:7059/configtxlator/compute/update-from-configs" target="_blank" rel="noopener">http://127.0.0.1:7059/configtxlator/compute/update-from-configs</a> -F channel=testchainid &gt; config_update.pb</p>
<p>At this point, the computed config update is now prepared. Traditionally,<br>an SDK would be used to sign and wrap this message. However, in the interest of<br>using only the peer cli, the <code>configtxlator</code> can also be used for this task.</p>
<p>到此，计算出的配置更新已经准备好了。一般，SDK 会对该消息进行签名打包。<br>然而，为了那些只使用节点命令（peer cli）的情况， <code>configtxlator</code> 工具也能进行这个工作。</p>
<p>First, we decode the ConfigUpdate so that we may work with it as text:</p>
<p>首先，按上文所说对配置更新进行编码：</p>
<p>.. code:: bash</p>
<p>$ curl -X POST –data-binary @config_update.pb <a href="http://127.0.0.1:7059/protolator/decode/common.ConfigUpdate" target="_blank" rel="noopener">http://127.0.0.1:7059/protolator/decode/common.ConfigUpdate</a> &gt; config_update.json</p>
<p>Then, we wrap it in an envelope message:</p>
<p>然后，讲消息进行打包：</p>
<p>.. code:: bash</p>
<p>echo ‘{“payload”:{“header”:{“channel_header”:{“channel_id”:”testchainid”, “type”:2}},”data”:{“config_update”:’$(cat config_update.json)’}}}’ &gt; config_update_as_envelope.json</p>
<p>Next, convert it back into the proto form of a full fledged config<br>transaction:</p>
<p>接着，将它转换为完整配置的交易的原型结构</p>
<p>.. code:: bash</p>
<p>curl -X POST –data-binary @config_update_as_envelope.json <a href="http://127.0.0.1:7059/protolator/encode/common.Envelope" target="_blank" rel="noopener">http://127.0.0.1:7059/protolator/encode/common.Envelope</a> &gt; config_update_as_envelope.pb</p>
<p>Finally, submit the config update transaction to ordering to perform a config<br>update.</p>
<p>最后，将配置更新交易提交到排序服务。</p>
<p>.. code:: bash</p>
<p>peer channel update -f config_update_as_envelope.pb -c testchainid -o 127.0.0.1:7050</p>
<h2 id="Adding-an-organization增加组织"><a href="#Adding-an-organization增加组织" class="headerlink" title="Adding an organization增加组织"></a>Adding an organization<br />增加组织</h2><p>First start the <code>configtxlator</code>:</p>
<p>首先启动 <code>configtxlator</code> 服务：</p>
<p>.. code:: bash</p>
<p>$ configtxlator start<br>2017-05-31 12:57:22.499 EDT [configtxlator] main -&gt; INFO 001 Serving HTTP requests on port: 7059</p>
<p>Start the orderer using the <code>SampleDevModeSolo</code> profile option.</p>
<p>使用 <code>SampleDevModeSolo</code> 属性配置来启动排序服务。</p>
<p>.. code:: bash</p>
<p>ORDERER_GENERAL_LOGLEVEL=debug ORDERER_GENERAL_GENESISPROFILE=SampleDevModeSolo orderer</p>
<p>The process to add an organization then follows exactly like the batch size<br>example. However, instead of setting the batch size, a new org is defined at<br>the application level. Adding an organization is slightly more involved because<br>we must first create a channel, then modify its membership set.</p>
<p>增加组织的国政和修改区块大小的过程类似。然而，不同于设置区块大小，一个新的组织被定义在应用层。<br>增加一个组织涉及更多内容因为需要先创建通道，然后修改它的成员集。</p>
<p>.. Licensed under Creative Commons Attribution 4.0 International License<br><a href="https://creativecommons.org/licenses/by/4.0/" target="_blank" rel="noopener">https://creativecommons.org/licenses/by/4.0/</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Tiny Hill</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/qiushaoxi" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;qiushaoxi" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/mailto:x@qsx.io" title="E-Mail &amp;rarr; mailto:x@qsx.io" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tiny Hill</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
